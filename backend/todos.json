[
  {
    "id": 1757313404066,
    "title": "Tìm hiểu về this trong Javascript",
    "description": "this là một từ khóa đặc biệt trong Javascript, giá trị của nó thay đổi tùy thuộc vào ngữ cảnh (context) mà nó được gọi. \nthis tham chiếu đến đối tượng mà hàm (function) đang được thực thi bên trong.\n\nTrong phạm vi toàn cục (Global Scope):\nKhi được sử dụng ở ngoài cùng (không trong hàm nào), this sẽ tham chiếu đến đối tượng toàn cục.\nTrong môi trường trình duyệt, là đối tượng window.\n\nBên trong một phương thức của đối tượng (Object Method):\nKhi một hàm được gọi với tư cách là một phương thức của một đối tượng, this sẽ trỏ đến chính đối tượng đó.\n\nTrong một hàm thông thường (Regular Function):\nỞ chế độ không nghiêm ngặt (non-strict mode), this sẽ lại tham chiếu đến đối tượng toàn cục (window).\nTuy nhiên, ở chế độ nghiêm ngặt (strict mode), this sẽ có giá trị là undefined.\n\nTrong hàm tạo (Constructor Function) hoặc Class:\nKhi sử dụng từ khóa new để tạo một thực thể (instance) mới, this sẽ tham chiếu đến chính đối tượng mới đang được tạo ra.\n\nVới hàm mũi tên (Arrow Function):\nHàm mũi tên không tạo ra ngữ cảnh this của riêng mình.\n-> nó sẽ \"mượn\" giá trị this từ ngữ cảnh bao bọc bên ngoài nó tại thời điểm nó được định nghĩa.",
    "completed": true
  },
  {
    "id": 1757313482105,
    "title": "First-class function trong Javascript",
    "description": "Định nghĩa: Trong Javascript, khái niệm \"First-class Function\" (Hàm hạng nhất) có nghĩa là một hàm (function) được đối xử như một giá trị (value) thông thường. Điều này có nghĩa là hàm có thể làm được mọi thứ mà các loại dữ liệu khác như số, chuỗi, hay đối tượng có thể làm.\n\nGán cho một biến: có thể khai báo một hàm và gán nó vào một biến để gọi sau này.\n\nTruyền như một tham số: một hàm có thể được truyền vào bên trong một hàm khác dưới dạng đối số (argument). Đây là nền tảng của các khái niệm như hàm gọi lại (callback).\n\nĐược trả về từ một hàm khác: một hàm có thể thực thi và trả về một hàm khác như là kết quả của nó.\n\nLưu trữ trong các cấu trúc dữ liệu: có thể lưu trữ các hàm bên trong một mảng (array) hoặc dưới dạng thuộc tính của một đối tượng (object).\n\nFirst-class Function - Hàm cũng là một loại giá trị.",
    "completed": true
  },
  {
    "id": 1757313568735,
    "title": "Thế nào là scopes ? Trong Javascript có những kiểu scopes gì?",
    "description": "Scope được định nghĩa là phạm vi mà một biến có thể được truy cập trong mã: \nkhi bạn khai báo một biến ở đâu, nó chỉ có thể được sử dụng trong phạm vi đó.\n\nGlobal Scope (Phạm vi toàn cục)\nĐây là phạm vi ngoài cùng. Một biến được khai báo trong Global Scope có thể được truy cập và sử dụng ở mọi nơi trong toàn bộ chương trình.\n\nFunction Scope (Phạm vi hàm)\nMột biến được khai báo bên trong một hàm sẽ thuộc về phạm vi của hàm đó.\nNó chỉ có thể được sử dụng bên trong hàm đã định nghĩa nó. Việc cố gắng truy cập biến này từ bên ngoài hàm sẽ gây ra lỗi.\n\nBlock Scope (Phạm vi khối)\nĐược giới thiệu từ ES6 với hai từ khóa let và const.\nMột \"khối\" (block) là bất kỳ đoạn mã nào nằm trong cặp dấu ngoặc nhọn { } (ví dụ như trong câu lệnh if, vòng lặp for,...).\nBiến được khai báo trong một khối chỉ tồn tại và có thể truy cập được bên trong khối đó.\n\nLexical Scope (Phạm vi từ vựng)\nLexical Scope có nghĩa là phạm vi của một biến được xác định tại thời điểm nó được viết (tức là dựa trên vị trí của nó trong mã nguồn).\nMột đặc điểm quan trọng của nó là hàm con có thể truy cập các biến của hàm cha bao bọc nó. Đây cũng chính là cơ chế tạo nên Closures trong Javascript.",
    "completed": true
  },
  {
    "id": 1757313869155,
    "title": "Thế nào là closure ?",
    "description": "Closure là một khái niệm quan trọng trong Javascript, mô tả khả năng của một hàm con có thể truy cập và sử dụng các biến thuộc về hàm cha của nó, ngay cả khi hàm cha đã thực thi xong.\n\n(hàm con \"nhớ\" được môi trường (phạm vi - scope) tại nơi nó được tạo ra. )\n\nCơ chế hoạt động:\nKhi một hàm cha chạy và trả về một hàm con, hàm con đó không chỉ là một đoạn mã. Nó mang theo một \"liên kết\" đến các biến của hàm cha. Do đó, mặc dù hàm cha đã kết thúc, các biến của nó vẫn được \"giữ lại\" trong bộ nhớ để hàm con có thể sử dụng khi cần.\n\nTH hay gặp: tạo ra một bộ đếm (counter). Nhờ có closure, biến count sẽ được \"giữ lại\" và bảo vệ bên trong. Mỗi lần gọi hàm con, nó sẽ truy cập và cập nhật chính biến count đó, thay vì tạo ra một biến mới và reset giá trị về 0.\n",
    "completed": true
  },
  {
    "id": 1757314170842,
    "title": "Phân biệt function expression với function statement? IIFE là gì?",
    "description": "1. Function Statement (hay Function Declaration)\nĐịnh nghĩa: Đây là cách khai báo hàm truyền thống, sử dụng từ khóa function và bắt buộc phải có tên.\nHoisting: Điểm đặc biệt nhất là nó được hoisting toàn bộ. Điều này có nghĩa là trình thông dịch Javascript sẽ \"đưa\" toàn bộ định nghĩa hàm lên đầu phạm vi của nó trước khi mã được thực thi.\nHệ quả: Do được hoisting, bạn có thể gọi hàm trước cả khi bạn định nghĩa nó trong mã nguồn.\n\n2. Function Expression\nĐịnh nghĩa: Đây là cách định nghĩa một hàm bằng cách gán nó cho một biến. Hàm này có thể có tên hoặc là một hàm ẩn danh (không có tên).\nHoisting: Chỉ có tên biến là được hoisting, nhưng giá trị của nó (chính là hàm) thì không. Tại thời điểm hoisting, biến sẽ có giá trị là undefined.\nHệ quả: Bạn không thể gọi hàm trước dòng lệnh gán vì tại thời điểm đó, biến chưa thực sự chứa hàm.\nĐặc điểm: Cách này rất linh hoạt, thường được sử dụng làm hàm gọi lại (callback), trong các closure, hoặc khi cần truyền hàm như một giá trị.\n\n3. IIFE (Immediately Invoked Function Expression)\nĐịnh nghĩa: Đây là một hàm được định nghĩa và thực thi ngay lập tức sau khi tạo.\nCú pháp & Cơ chế: Người ta dùng một cặp dấu ngoặc tròn () để bao bọc toàn bộ hàm, biến nó thành một biểu thức (expression). Sau đó, thêm một cặp ngoặc tròn () nữa ở cuối để gọi nó ngay.\nMục đích chính: Trước khi let và const ra đời, IIFE là cách phổ biến nhất để tạo ra một scope riêng biệt. Điều này giúp các biến được khai báo bên trong nó không bị \"rò rỉ\" ra ngoài, tránh xung đột với các biến trong phạm vi toàn cục (global scope).",
    "completed": true
  },
  {
    "id": 1757314233629,
    "title": "Thế nào là prototype?",
    "description": "Trong Javascript, Prototype là một khái niệm cốt lõi, đóng vai trò là cơ chế kế thừa chính. Mỗi đối tượng (object) trong Javascript đều có một liên kết ẩn (thường được biết đến qua __proto__) trỏ đến một đối tượng khác, được gọi là prototype của nó.\n\nĐối tượng prototype này chứa các thuộc tính (properties) và phương thức (methods) mà các đối tượng khác có thể chia sẻ và sử dụng lại.\n\nChuỗi Prototype (Prototype Chain) hoạt động như thế nào?\nKhi bạn cố gắng truy cập một thuộc tính hoặc phương thức từ một đối tượng:\nĐầu tiên, Javascript sẽ tìm kiếm ngay bên trong chính đối tượng đó.\nNếu không tìm thấy, nó sẽ đi theo liên kết ẩn để tìm kiếm trong đối tượng prototype của nó.\nQuá trình này cứ tiếp tục lặp lại, tạo thành một chuỗi liên kết gọi là chuỗi prototype (prototype chain), cho đến khi tìm thấy thuộc tính/phương thức hoặc đến khi chuỗi kết thúc.\nNếu tìm đến cuối chuỗi mà vẫn không thấy, kết quả trả về sẽ là undefined.",
    "completed": true
  },
  {
    "id": 1757314244792,
    "title": "ECMAScript2015 (ES6) là gì? ECMAScript2015 có những điểm gì mới?",
    "description": "1. ECMAScript là gì?\nECMAScript (ES) là một tiêu chuẩn được phát hành bởi tổ chức ECMA International. Tiêu chuẩn này định nghĩa các quy tắc, cú pháp và tính năng mà một ngôn ngữ kịch bản cần phải tuân theo.\nJavaScript chính là một hiện thực (implementation) nổi tiếng nhất của tiêu chuẩn ECMAScript. Có thể hiểu đơn giản là \"JavaScript chạy theo luật mà ECMAScript quy định\".\n\n2. ECMAScript 2015 (ES6) là gì?\nECMAScript 2015, thường được gọi là ES6, là phiên bản thứ 6 của tiêu chuẩn ECMAScript, được phát hành vào năm 2015.\nĐây được coi là bản cập nhật lớn và quan trọng nhất trong lịch sử của JavaScript, mang đến hàng loạt cú pháp và tính năng mới mạnh mẽ. Mục tiêu của ES6 là giúp mã JavaScript trở nên gọn gàng, dễ đọc hơn, hỗ trợ lập trình hướng đối tượng tốt hơn và cung cấp các giải pháp mạnh mẽ cho lập trình bất đồng bộ.\nSau ES6, các phiên bản mới được phát hành đều đặn hàng năm (ES7, ES8,...) và thường được gọi chung là ESNext.\n\n3. Những điểm mới quan trọng trong ES6\n\nCách khai báo biến mới (let, const):\nRa đời để thay thế cho var, giúp quản lý biến chặt chẽ hơn.\nĐiểm quan trọng nhất là chúng tuân theo phạm vi khối (block scope).\n\nArrow Function:\nCung cấp cú pháp viết hàm ngắn gọn hơn và không tạo ra ngữ cảnh this của riêng nó.\n\nTemplate Literals:\nSử dụng dấu backtick (`) để tạo chuỗi, cho phép chèn biến trực tiếp vào chuỗi và viết chuỗi trên nhiều dòng một cách dễ dàng.\n\nDefault Parameters:\nCho phép thiết lập giá trị mặc định cho các tham số của hàm.\n\nDestructuring:\nCú pháp tiện lợi để trích xuất (bóc tách) các giá trị từ mảng hoặc thuộc tính từ đối tượng vào các biến riêng lẻ.\n\nSpread / Rest Operator (...):\nSpread: Dùng để \"trải\" các phần tử của một mảng hoặc thuộc tính của một đối tượng ra.\nRest: Dùng để \"gom\" các tham số còn lại của một hàm vào một mảng.\n\nClasses:\nCung cấp một cú pháp mới, rõ ràng và quen thuộc hơn (giống các ngôn ngữ như Java, C#) để tạo các đối tượng và xử lý kế thừa, về bản chất vẫn dựa trên cơ chế prototype của JavaScript.\n\nModules (import/export):\nMột hệ thống chính thức để chia nhỏ mã nguồn thành các tệp tin độc lập (modules) và tái sử dụng chúng khi cần.\n\nPromises:\nMột đối tượng đại diện cho sự hoàn thành (hoặc thất bại) của một tác vụ bất đồng bộ, cung cấp một cách xử lý rõ ràng và hiệu quả hơn so với \"callback hell\".\n",
    "completed": true
  },
  {
    "id": 1757314266868,
    "title": "Thế nào là Arrow Function? Cách thức sử dụng Arrow Function và những điều cần chú ý",
    "description": "Arrow function (hàm mũi tên) về cơ bản cũng là một hàm (function) trong Javascript. Điểm khác biệt và cũng là ưu điểm lớn nhất của nó là có cú pháp khai báo ngắn gọn hơn nhiều so với hàm thông thường, bằng cách sử dụng dấu mũi tên => thay cho từ khóa function.\n\nTrong nhiều trường hợp đơn giản, nó còn cho phép bỏ qua cả dấu ngoặc nhọn {} và từ khóa return, giúp mã nguồn trở nên tinh gọn hơn.\n\nCác đặc điểm và lưu ý quan trọng\nMặc dù cú pháp ngắn gọn, arrow function có những khác biệt cơ bản so với hàm thông thường cần lưu ý:\n\nKhông có ngữ cảnh this của riêng nó: Đây là điểm khác biệt quan trọng nhất. Arrow function không tạo ra this mới; thay vào đó, nó sẽ \"mượn\" giá trị this từ phạm vi (scope) bao bọc bên ngoài nó tại thời điểm nó được định nghĩa.\n\nKhông có đối tượng arguments: Khác với hàm thông thường, không thể truy cập đối tượng arguments bên trong một arrow function để lấy danh sách tất cả các đối số đã truyền vào.\n\nKhông thể dùng làm hàm tạo (constructor): gặp lỗi nếu cố gắng sử dụng từ khóa new với một arrow function.\n",
    "completed": true
  },
  {
    "id": 1757314278754,
    "title": "Tìm hiểu về promise trong javascript",
    "description": "Tác vụ bất đồng bộ (Asynchronous Task)\nTrước khi hiểu về Promise, cần biết về tác vụ bất đồng bộ. Đây là những công việc không chặn luồng xử lý chính của chương trình. Khi một tác vụ bất đồng bộ được gọi, chương trình không cần phải dừng lại chờ nó hoàn thành mà có thể tiếp tục thực thi các công việc khác.\nĐặc điểm:\nKhông đồng bộ: Các tác vụ chạy song song hoặc trong nền, không cần chờ tác vụ trước kết thúc.\nKết quả trả về sau: Kết quả của tác vụ sẽ được trả về sau đó thông qua các cơ chế như callback, Promise, hoặc async/await.\n\n1. Promise là gì?\nPromise là một đối tượng đặc biệt trong Javascript, được thiết kế để xử lý các tác vụ bất đồng bộ.\nNó đại diện cho một giá trị có thể chưa có ở hiện tại nhưng sẽ có trong tương lai (hoặc là kết quả thành công, hoặc là lỗi).\n(Promise giống như một \"lời hứa\": nó hứa rằng sẽ trả về một kết quả nào đó sau khi hoàn thành công việc. Mục đích chính của nó là giúp việc viết mã bất đồng bộ trở nên dễ đọc và quản lý hơn, giải quyết vấn đề \"callback hell\".)\n\n2. Ba trạng thái của một Promise\nMột Promise luôn ở một trong ba trạng thái sau:\nPending (Đang chờ): Trạng thái ban đầu, khi \"lời hứa\" chưa được thực hiện, tác vụ chưa hoàn thành.\nFulfilled (Thành công): Tác vụ đã hoàn thành và trả về một kết quả thành công (thông qua hàm resolve).\nRejected (Thất bại): Tác vụ đã gặp lỗi và trả về một lý do thất bại (thông qua hàm reject).\n\n3. Tạo và sử dụng Promise\nMột Promise được tạo ra bằng cách truyền vào một hàm thực thi (executor function). Hàm này nhận vào hai tham số là hai hàm khác: resolve và reject.\nresolve(value): Được gọi khi tác vụ thành công, chuyển trạng thái của Promise thành fulfilled.\nreject(error): Được gọi khi có lỗi xảy ra, chuyển trạng thái của Promise thành rejected.\nĐể xử lý kết quả từ một Promise, chúng ta sử dụng các phương thức:\n.then(): Dùng để xử lý kết quả khi Promise thành công (fulfilled).\n.catch(): Dùng để bắt và xử lý lỗi khi Promise thất bại (rejected).\n.finally(): Chứa đoạn mã luôn được thực thi sau khi Promise kết thúc, bất kể là thành công hay thất bại.\n\n4. Xâu chuỗi Promise (Promise Chaining)\nMột trong những sức mạnh lớn nhất của Promise là khả năng xâu chuỗi (chaining). Bạn có thể nối nhiều phương thức .then() liên tiếp với nhau. Kết quả trả về từ một .then() sẽ trở thành đầu vào cho .then() tiếp theo, tạo ra một luồng xử lý tuần tự và dễ đọc cho các tác vụ bất đồng bộ.\n\n5. Kết hợp nhiều Promise\nJavascript cung cấp các phương thức để xử lý nhiều Promise cùng lúc:\nPromise.all: Thực thi nhiều Promise cùng một lúc và chỉ được coi là thành công (fulfilled) khi tất cả các Promise trong mảng đều thành công. Nếu có bất kỳ Promise nào thất bại, Promise.all sẽ ngay lập tức thất bại.\nPromise.race: Cũng thực thi nhiều Promise cùng lúc, nhưng nó sẽ trả về kết quả của Promise hoàn thành đầu tiên, bất kể là thành công hay thất bại.",
    "completed": true
  },
  {
    "id": 1757314290683,
    "title": "Promise vs Async/Await",
    "description": "Vấn đề \"Callback Hell\"\nviệc xử lý các tác vụ bất đồng bộ phụ thuộc lẫn nhau thường dẫn -> \"Callback Hell\"\n\"Callback Hell\" là khái niệm chỉ việc mã nguồn trở nên cực kỳ khó đọc và khó bảo trì do phải sử dụng quá nhiều hàm callback lồng vào nhau. Cấu trúc mã lúc này sẽ có dạng nhiều lớp ngoặc sâu, rất khó để theo dõi luồng thực thi.\n\n1. Promise: Giải pháp đầu tiên\nPromise là một đối tượng được sinh ra để xử lý các tác vụ bất đồng bộ và là giải pháp đầu tiên giúp tránh được Callback Hell.\nCho phép xử lý kết quả thành công hoặc thất bại một cách tuần tự thông qua các phương thức .then() và .catch().\nTuy nhiên, khi phải thực hiện nhiều bước, việc xâu chuỗi nhiều phương thức .then() liên tiếp đôi khi vẫn có thể khiến mã trở nên dài và hơi khó theo dõi.\n\n2. Async/Await: Cú pháp nâng cao và dễ đọc hơn\nAsync/Await là một cú pháp được giới thiệu trong ES2017, được xây dựng dựa trên nền tảng của Promise để giúp việc viết mã bất đồng bộ trở nên đơn giản hơn nữa.\nTừ khóa async khi đặt trước một hàm sẽ biến nó thành một hàm bất đồng bộ, luôn ngầm trả về một Promise.\nTừ khóa await (chỉ dùng được trong hàm async) sẽ tạm dừng việc thực thi hàm cho đến khi Promise mà nó chờ đợi được giải quyết.\nKết hợp async/await -> viết mã bất đồng bộ trông giống hệt như mã đồng bộ tuần tự -> code dễ đọc và dễ hiểu.\n\n3. So sánh trực tiếp Promise và Async/Await\n\nVề cú pháp:\nPromise: Sử dụng chuỗi phương thức .then() để xử lý thành công và .catch() để xử lý lỗi.\nAsync/Await: Sử dụng từ khóa await để chờ kết quả bên trong một hàm có từ khóa async.\n\nVề khả năng đọc:\nPromise: Có thể trở nên rối khi có nhiều bước .then() nối tiếp nhau.\nAsync/Await: Mã trông giống như mã đồng bộ, rất sạch sẽ và dễ theo dõi luồng thực thi từ trên xuống dưới.\n\nVề xử lý lỗi:\nPromise: Sử dụng phương thức .catch() ở cuối chuỗi để bắt tất cả lỗi xảy ra.\nAsync/Await: Sử dụng khối try...catch quen thuộc, một cấu trúc mà nhiều lập trình viên đã rất quen thuộc.\n\nVề thực thi song song:\nCả hai đều sử dụng Promise.all() để chạy nhiều tác vụ cùng lúc. Với Async/Await, bạn chỉ cần đặt await trước Promise.all([...]) để chờ tất cả hoàn thành.",
    "completed": true
  },
  {
    "id": 1757314301613,
    "title": "Tìm hiểu về nodejs , npm",
    "description": "1. Node.js là gì?\nNode.js là một môi trường cho phép bạn chạy mã JavaScript bên ngoài trình duyệt, chủ yếu ở phía máy chủ (backend). Về cơ bản, nó mang JavaScript từ front-end ra back-end.\nĐặc điểm cốt lõi của Node.js là cơ chế bất đồng bộ (non-blocking I/O), giúp nó xử lý hiệu quả hàng ngàn kết nối cùng lúc mà không bị tắc nghẽn. Nhờ đó, nó cực kỳ mạnh mẽ để xây dựng các máy chủ web, API, và các ứng dụng thời gian thực như ứng dụng chat.\n\n2. npm là gì?\nnpm (Node Package Manager) là trình quản lý gói đi kèm với Node.js. \nNó cung cấp hai thứ chính:\nMột kho lưu trữ trực tuyến khổng lồ (npm registry) chứa các thư viện mã nguồn mở (gọi là các \"gói\").\nMột công cụ dòng lệnh để bạn dễ dàng cài đặt và quản lý các thư viện đó cho dự án của mình.\nMọi dự án Node.js đều có một tệp package.json. Đây là tệp tin ghi lại thông tin dự án và liệt kê tất cả các thư viện mà dự án cần để hoạt động.\n\n3. Mối quan hệ giữa Node.js và npm\nNode.js và npm là một cặp đôi không thể tách rời.\nNode.js là cỗ máy để chạy mã.\nnpm là cửa hàng công cụ cung cấp các linh kiện (thư viện) cần thiết cho cỗ máy đó.\nsử dụng npm để cài đặt các gói như express (để tạo máy chủ) hoặc axios (để gọi API), sau đó dùng Node.js để chạy đoạn mã có sử dụng các gói đó.\n\nTóm tắt \nNode.js: Môi trường để chạy JavaScript ở backend, cực kỳ hiệu quả cho các tác vụ I/O (vào/ra).\nnpm: Công cụ để quản lý các thư viện (gói) cho dự án Node.js của bạn.\npackage.json: Tệp tin khai báo các thư viện phụ thuộc của dự án.",
    "completed": true
  },
  {
    "id": 1757314313693,
    "title": "Tìm hiểu về webpack",
    "description": "1. Webpack là gì?\nWebpack là một module bundler (trình đóng gói module) hiện đại và mạnh mẽ cho các ứng dụng JavaScript.\n1 ứng dụng web phức tạp có rất nhiều tệp: các tệp JavaScript, CSS, hình ảnh, phông chữ,... \n-> Webpack sẽ lấy tất cả các tệp đó, xử lý, tối ưu hóa chúng và biến chúng thành một vài tệp tĩnh, gọn gàng mà trình duyệt có thể hiểu và chạy một cách hiệu quả.\n\n2. Vấn đề mà Webpack giải quyết\nTrước khi có các công cụ như Webpack, việc quản lý mã nguồn ở phía front-end rất phức tạp:\nQuá nhiều tệp: Bạn phải chèn hàng chục thẻ <script> và <link> vào tệp HTML. Điều này tạo ra rất nhiều yêu cầu HTTP, làm chậm tốc độ tải trang.\nPhụ thuộc lẫn nhau: Thứ tự của các thẻ <script> rất quan trọng. Nếu tệp B phụ thuộc vào tệp A, bạn phải đảm bảo tệp A được tải trước. Việc quản lý này rất dễ gây lỗi.\nBiến toàn cục: Các biến được khai báo trong các tệp khác nhau có thể xung đột với nhau trong phạm vi toàn cục (global scope).\nKhông có hệ thống module: JavaScript ban đầu không có hệ thống module chính thức để chia nhỏ và tái sử dụng mã một cách có tổ chức.\n\n-> Webpack ra đời để giải quyết tất cả những vấn đề này bằng cách cho phép bạn sử dụng hệ thống module (như ES Modules với import/export) và tự động đóng gói mọi thứ lại.\n\n3. Các khái niệm cốt lõi của Webpack\n\nBốn khái niệm chính sau:\n\nEntry (Điểm đầu vào): Đây là tệp tin mà Webpack sẽ bắt đầu \"hành trình\" đóng gói của mình. Từ tệp này, Webpack sẽ xây dựng một \"sơ đồ phụ thuộc\" (dependency graph) bằng cách lần theo tất cả các lệnh import và require để tìm ra tất cả các module và tài sản mà ứng dụng của bạn cần.\n\nOutput (Đầu ra): Đây là nơi Webpack sẽ lưu các tệp đã được đóng gói sau khi xử lý xong. Bạn sẽ chỉ định tên tệp và thư mục đầu ra, ví dụ như một tệp bundle.js nằm trong thư mục dist.\n\nLoaders (Trình tải): Mặc định, Webpack chỉ hiểu các tệp JavaScript và JSON. Loaders là những \"giáo viên\" giúp Webpack \"học\" cách xử lý các loại tệp khác. \nVí dụ:\ncss-loader và style-loader giúp Webpack đọc và chèn mã CSS vào trang web.\nbabel-loader giúp chuyển đổi mã JavaScript hiện đại (ES6+) thành mã ES5 tương thích với các trình duyệt cũ.\nfile-loader hoặc asset modules giúp xử lý các tệp hình ảnh, phông chữ.\n\nPlugins (Phần mở rộng): Trong khi Loaders chỉ làm việc trên từng tệp riêng lẻ, Plugins có thể thực hiện các tác vụ rộng hơn và phức tạp hơn trên toàn bộ quá trình đóng gói.\nVí dụ:\nHtmlWebpackPlugin tự động tạo ra một tệp HTML và chèn tệp JavaScript đã được đóng gói vào đó.\nMiniCssExtractPlugin tách mã CSS ra thành một tệp riêng biệt thay vì để chung với JavaScript.\nCác plugin tối ưu hóa mã nguồn (như TerserWebpackPlugin) giúp nén và làm gọn mã của bạn.\n\n4. Cách Webpack hoạt động - Sơ đồ phụ thuộc (Dependency Graph)\n\nWebpack bắt đầu từ tệp Entry mà đã chỉ định.\nNó phân tích tệp này và tìm kiếm các lệnh import hoặc require để xác định các tệp phụ thuộc.\nNó tiếp tục quá trình này một cách đệ quy với từng tệp phụ thuộc, xây dựng nên một sơ đồ hoàn chỉnh về tất cả các tài sản mà ứng dụng cần.\nTrong quá trình này, khi gặp các loại tệp khác nhau (như .css, .png), Webpack sẽ sử dụng các Loaders tương ứng để xử lý chúng.\nSau khi đã có sơ đồ phụ thuộc và đã xử lý tất cả các tệp, Webpack sẽ sử dụng các Plugins để thực hiện các tác vụ bổ sung.\nCuối cùng, nó đóng gói tất cả lại thành các tệp tĩnh và lưu vào thư mục Output.\n\n5. Lợi ích Webpack\nQuản lý module hiệu quả: Cho phép viết mã theo chuẩn module, giúp mã nguồn có tổ chức, dễ bảo trì và tái sử dụng.\nTối ưu hóa hiệu suất: Webpack có thể nén (minify), gộp file, và loại bỏ mã chết (tree shaking) để giảm kích thước tệp cuối cùng, giúp trang web tải nhanh hơn.\nXử lý nhiều loại tài sản: Không chỉ JavaScript, Webpack có thể xử lý CSS, SASS, hình ảnh, phông chữ,... một cách thống nhất.\nMôi trường phát triển mạnh mẽ: Với webpack-dev-server, bạn có được tính năng tải lại nóng (Hot Module Replacement - HMR), giúp bạn thấy thay đổi ngay lập tức mà không cần làm mới toàn bộ trang.",
    "completed": true
  },
  {
    "id": 1757314322690,
    "title": "Cài đặt , config và sử dụng ESLint",
    "description": "done",
    "completed": true
  },
  {
    "id": 1757314334116,
    "title": "Typescript và ES6",
    "description": "ES6 (ECMAScript 2015)\nLà một phiên bản / tiêu chuẩn của ngôn ngữ JavaScript.\nCác tính năng nổi bật: let/const, Arrow Function, Class, Promise/Async/Await, import/export.\nMục tiêu: Giúp hiện đại hóa cú pháp và chức năng của JavaScript.\nBạn đang viết code JavaScript thuần túy.\n\nTypeScript (TS)\nLà một tập hợp cha (superset) của JavaScript. (Mọi code JS hợp lệ đều là code TS hợp lệ).\nTính năng cốt lõi: Thêm vào hệ thống kiểu dữ liệu tĩnh (static types).\nBắt buộc phải có bước biên dịch: Code .ts phải được biên dịch thành code .js để có thể chạy.\nMục tiêu: Giúp bắt lỗi sớm (ngay lúc viết code) và làm cho các dự án lớn trở nên an toàn, dễ bảo trì hơn.\n\nSo sánh : \n\nKiểu dữ liệu:\nES6: Kiểu động (Dynamic) - Kiểm tra lúc chương trình chạy.\nTS: Kiểu tĩnh (Static) - Kiểm tra ngay lúc viết code.\n\nPhát hiện lỗi:\nES6: Lỗi kiểu dữ liệu xảy ra lúc chạy (runtime).\nTS: Lỗi kiểu dữ liệu được báo ngay lúc viết code / biên dịch (compile-time).\n\nQuá trình Build:\nES6: Không bắt buộc.\nTS: Bắt buộc.\n\nKhi nào dùng?\nDùng ES6 (JavaScript):\nDự án nhỏ, các script đơn giản.\nLàm prototype nhanh.\nKhi mới học JavaScript.\n\nDùng TypeScript:\nDự án lớn, phức tạp.\nLàm việc nhóm.\nKhi cần độ tin cậy và bảo trì cao.",
    "completed": true
  },
  {
    "id": 1757314344659,
    "title": "Viết và publish 1 npm package",
    "description": "done",
    "completed": true
  },
  {
    "id": 1757314355512,
    "title": "Yarn là gì , yarn và npm",
    "description": "1. Định nghĩa \nnpm: Trình quản lý gói mặc định, đi kèm với Node.js.\nYarn: Trình quản lý gói được tạo ra để thay thế npm, với mục tiêu ban đầu là Nhanh & Tin cậy.\n\n2. So sánh \nTốc độ:\nTrước đây Yarn nhanh hơn.\nHiện tại: Tốc độ gần như tương đương. Đây không còn là yếu tố quyết định.\n\nĐộ tin cậy (Lock File):\nCả hai đều tạo ra lock file (package-lock.json của npm, yarn.lock của Yarn).\nKết quả: Cả hai đều đảm bảo tính nhất quán 100% cho dự án trên mọi máy.\n\nCâu lệnh (Điểm khác biệt về trải nghiệm):\nnpm install <package> vs yarn add <package>\nnpm run <script> vs yarn <script> (Yarn không cần run)\nNhìn chung, lệnh của Yarn ngắn gọn hơn.\n\nTính năng nâng cao:\nYarn được đánh giá cao hơn với tính năng Workspaces (quản lý monorepo - nhiều dự án trong một repo).\n\n3. Kết luận: Nên dùng cái nào?\nChọn npm nếu:\nNgười mới, thích sự đơn giản và không muốn cài thêm gì.\nDự án không có yêu cầu đặc biệt.\nChọn Yarn nếu:\nThích giao diện dòng lệnh (CLI) gọn gàng và các câu lệnh ngắn hơn.\nBạn làm việc với monorepo phức tạp.\n\n4. LƯU Ý\nKHÔNG dùng lẫn lộn cả hai trong cùng một dự án.  CHỈ sử dụng MỘT LOẠI để tránh xung đột giữa hai tệp lock file.",
    "completed": true
  }
]